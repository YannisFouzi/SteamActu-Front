import AsyncStorage from '@react-native-async-storage/async-storage';
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';
import {Alert, AppState} from 'react-native';
import {
  useAsyncStorage,
  useLastVerificationDate,
} from '../hooks/useAsyncStorage';
import {useGameSync} from '../hooks/useGameSync';
import {steamService, userService} from '../services/api';
import {
  getGameAppId,
  getGameIconUrl,
  getLastPlayedValue,
  getLastUpdateValue,
  getPlaytimeForeverValue,
  isRecentlyUpdated,
} from '../utils/gameHelpers';

// Cr√©ation du contexte
const AppContext = createContext();

// Hook personnalis√© pour utiliser le contexte
export const useAppContext = () => useContext(AppContext);

// Provider du contexte
export const AppProvider = ({children, navigation = null}) => {
  // Hooks personnalis√©s
  const {syncRecentActiveGames} = useGameSync();
  const {updateVerificationDate, isOlderThanOneDay} = useLastVerificationDate();

  // √âtats principaux
  const [games, setGames] = useState([]);
  const [filteredGames, setFilteredGames] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [steamId, setSteamId] = useState('');
  const [user, setUser] = useState(null);
  const [lastRefreshTime, setLastRefreshTime] = useState(Date.now());

  // √âtat de l'application
  const appState = useRef(AppState.currentState);

  // Recherche et tri
  const [searchQuery, setSearchQuery] = useState('');
  const [sortModalVisible, setSortModalVisible] = useState(false);
  const [sortOption, setSortOption] = useAsyncStorage('sortOption', 'default');

  // Filtre pour les jeux suivis
  const [filterModalVisible, setFilterModalVisible] = useState(false);
  const [followFilter, setFollowFilter] = useAsyncStorage(
    'followFilter',
    'all',
  );

  // Chargement initial des donn√©es
  useEffect(() => {
    loadData();

    // Configurer la d√©tection du changement d'√©tat de l'application
    const subscription = AppState.addEventListener('change', nextAppState => {
      if (
        appState.current.match(/inactive|background/) &&
        nextAppState === 'active'
      ) {
        console.log('App revenue au premier plan!');
        checkLastVerificationDate();
      }

      appState.current = nextAppState;
    });

    // Les options de tri et filtre sont maintenant g√©r√©es par useAsyncStorage

    return () => {
      subscription.remove();
    };
  }, []);

  // Surveiller les changements de steamId pour recharger les donn√©es apr√®s reconnexion
  useEffect(() => {
    if (steamId) {
      // Utiliser setRefreshing pour afficher les indicateurs de chargement
      setRefreshing(true);
      loadData().finally(() => setRefreshing(false));
    }
  }, [steamId]);

  // La persistance des options est maintenant g√©r√©e automatiquement par useAsyncStorage

  // Filtrer et trier les jeux quand les crit√®res changent
  useEffect(() => {
    if (games && Array.isArray(games) && (games.length > 0 || searchQuery)) {
      filterAndSortGames();
    } else {
      setFilteredGames([]);
    }
  }, [games, searchQuery, sortOption, followFilter]);

  // Filtrer et trier les jeux
  const filterAndSortGames = useCallback(() => {
    console.log(
      'üîç filterAndSortGames appel√©e (m√©moris√©e) - searchQuery:',
      searchQuery,
      'games count:',
      games?.length,
    );
    if (!games || !Array.isArray(games)) {
      console.log('Aucun jeu √† filtrer ou format incorrect');
      setFilteredGames([]);
      return;
    }

    let filtered = [...games];

    // Appliquer le filtre de recherche
    if (searchQuery && searchQuery.trim() !== '') {
      const query = searchQuery.toLowerCase().trim();
      filtered = filtered.filter(game =>
        game.name?.toLowerCase().includes(query),
      );
    }

    // Appliquer le filtre de suivi
    if (followFilter !== 'all') {
      filtered = filtered.filter(game => {
        const appId = getGameAppId(game);
        const isFollowed = isGameFollowed(appId);
        return followFilter === 'followed' ? isFollowed : !isFollowed;
      });
    }

    // Appliquer le tri
    switch (sortOption) {
      case 'alphabetical':
      case 'default':
        filtered.sort((a, b) => a.name.localeCompare(b.name));
        break;
      case 'recentlyUpdated':
        filtered.sort((a, b) => getLastUpdateValue(b) - getLastUpdateValue(a));
        break;
      case 'mostPlayed':
        filtered.sort(
          (a, b) => getPlaytimeForeverValue(b) - getPlaytimeForeverValue(a),
        );
        break;
      case 'recent':
        filtered.sort((a, b) => {
          return getLastPlayedValue(b) - getLastPlayedValue(a);
        });
        break;
      default:
        break;
    }

    setFilteredGames(filtered);
  }, [games, searchQuery, followFilter, sortOption, isGameFollowed]);

  // Fonction pour charger les donn√©es
  const loadData = async (isFullCheck = false) => {
    try {
      if (isFullCheck) {
        setLoading(true);
      }

      // V√©rifier s'il y a un identifiant Steam enregistr√©
      const savedSteamId = await AsyncStorage.getItem('steamId');

      // Si pas d'identifiant, retourner √† l'√©cran de connexion
      if (!savedSteamId) {
        setLoading(false);
        if (navigation) {
          navigation.navigate('Login');
          return; // Sortir de la fonction sans erreur
        }
        return;
      }

      // Si c'est le m√™me steamId, forcer quand m√™me le rechargement (reconnexion)
      if (steamId === savedSteamId) {
        // Afficher l'indicateur de chargement pour la reconnexion
        if (!isFullCheck) {
          setRefreshing(true);
        }
      } else {
        setSteamId(savedSteamId);
        return; // Laisser useEffect[steamId] g√©rer le chargement
      }

      setSteamId(savedSteamId);

      try {
        // R√©cup√©rer les informations de l'utilisateur
        const userResponse = await userService.getUser(savedSteamId);
        setUser(userResponse.data);

        // V√©rifier si nous pouvons utiliser getAllUserGames ou si nous devons revenir √† getUserGames
        let gamesResponse;
        try {
          // Utiliser directement getUserGames (m√©thode fiable)
          // Si le filtre est sur "followed", on ne r√©cup√®re que les jeux suivis
          const shouldFetchFollowedOnly = followFilter === 'followed';
          gamesResponse = await steamService.getUserGames(
            savedSteamId,
            shouldFetchFollowedOnly,
          );
        } catch (error) {
          setLoading(false);
          Alert.alert(
            'Erreur de connexion',
            'Impossible de r√©cup√©rer vos jeux. Veuillez v√©rifier votre connexion et r√©essayer.',
            [
              {
                text: 'R√©essayer',
                onPress: () => loadData(isFullCheck),
              },
              {
                text: 'D√©connexion',
                style: 'destructive',
                onPress: () => handleLogout(),
              },
            ],
          );
          return;
        }

        // Adapter la structure selon la r√©ponse re√ßue
        let newGames = [];
        if (gamesResponse.data && gamesResponse.data.games) {
          // Nouvelle structure (getAllUserGames)
          newGames = gamesResponse.data.games;
          console.log(
            `Structure getAllUserGames d√©tect√©e. ${newGames.length} jeux re√ßus.`,
          );
        } else if (
          gamesResponse.data &&
          Array.isArray(gamesResponse.data.games)
        ) {
          // Ancienne structure (getUserGames)
          newGames = gamesResponse.data.games;
          console.log(
            `Structure getUserGames d√©tect√©e. ${newGames.length} jeux re√ßus.`,
          );
        } else if (Array.isArray(gamesResponse.data)) {
          // Structure de secours
          newGames = gamesResponse.data;
        }

        // V√©rifier les donn√©es de tri disponibles
        if (newGames.length > 0) {
          // Ajout d'un timestamp pour les jeux qui n'en ont pas
          newGames.forEach(game => {
            if (!game.lastUpdateTimestamp) {
              const fallbackTimestamp = getLastPlayedValue(game);
              if (fallbackTimestamp > 0) {
                game.lastUpdateTimestamp = fallbackTimestamp;
              }
            }
          });
        }

        // Traiter et afficher les statistiques
        if (Array.isArray(newGames) && newGames.length > 0) {
          if (gamesResponse.data.apiGamesCount) {
            console.log(
              `D√©tails: ${
                gamesResponse.data.apiGamesCount || 0
              } jeux de l'API Steam, ${
                gamesResponse.data.databaseOnlyCount || 0
              } jeux uniquement en base de donn√©es`,
            );
          }
        } else {
          console.log('Aucun jeu r√©cup√©r√© ou format de r√©ponse inattendu');
        }

        // Enfin, mettre √† jour l'√©tat des jeux et arr√™ter le chargement
        const normalizedGames = Array.isArray(newGames) ? newGames : [];
        setGames(normalizedGames);
        syncRecentActiveGames(normalizedGames, savedSteamId);
        if (!isFullCheck) {
          setLoading(false);
        }

        // Arr√™ter l'indicateur de refreshing si activ√© (cas de reconnexion)
        setRefreshing(false);
      } catch (apiError) {
        console.error('Erreur API lors du chargement des donn√©es:', apiError);
        setLoading(false);
        setRefreshing(false);

        // V√©rifier si l'erreur est due √† un utilisateur non trouv√© (404)
        if (apiError.response && apiError.response.status === 404) {
          console.log(
            'Utilisateur non trouv√© dans la base de donn√©es, d√©connexion forc√©e',
          );
          Alert.alert(
            'Session expir√©e',
            'Votre session a expir√© ou votre compte a √©t√© supprim√©. Veuillez vous reconnecter.',
            [
              {
                text: 'OK',
                onPress: () => handleLogout(),
              },
            ],
          );
          return;
        }

        // Autres erreurs
        Alert.alert(
          'Erreur de connexion',
          'Impossible de r√©cup√©rer vos donn√©es. Veuillez v√©rifier votre connexion et r√©essayer.',
          [
            {
              text: 'R√©essayer',
              onPress: () => loadData(isFullCheck),
            },
            {
              text: 'D√©connexion',
              style: 'destructive',
              onPress: () => handleLogout(),
            },
          ],
        );
      }

      updateVerificationDate();
      setLastRefreshTime(Date.now());
    } catch (error) {
      console.error('üî¥ LOAD ERROR -', error.message);
      setLoading(false);
      setRefreshing(false);

      // Proposer √† l'utilisateur de se d√©connecter en cas d'erreur grave
      Alert.alert(
        'Erreur',
        "Une erreur inattendue s'est produite. Voulez-vous vous d√©connecter et r√©essayer?",
        [
          {
            text: 'R√©essayer',
            onPress: () => loadData(isFullCheck),
          },
          {
            text: 'D√©connexion',
            style: 'destructive',
            onPress: () => handleLogout(),
          },
        ],
      );
    }
  };

  // V√©rifier la derni√®re date de v√©rification
  const checkLastVerificationDate = async () => {
    try {
      if (isOlderThanOneDay()) {
        console.log("Plus d'un jour s'est √©coul√©, v√©rification compl√®te...");
        loadData(true);
      } else if (Date.now() - lastRefreshTime > 300000) {
        checkForNewGames();
      }
    } catch (error) {
      console.error('Erreur lors de la v√©rification de la date:', error);
    }
  };

  // Fonction pour rafra√Æchir les donn√©es
  const handleRefresh = () => {
    setRefreshing(true);
    loadData()
      .then(() => {
        setRefreshing(false);
      })
      .catch(error => {
        setRefreshing(false);
      });
  };

  // Fonction pour se d√©connecter
  const handleLogout = async () => {
    try {
      // Supprimer l'ID Steam du stockage
      await AsyncStorage.removeItem('steamId');

      // R√©initialiser les √©tats
      setSteamId('');
      setUser(null);
      setGames([]);
      setFilteredGames([]);

      // Navigation si disponible
      if (navigation) {
        navigation.replace('Login');
      } else {
        // Forcer un "rafra√Æchissement" pour que les composants se mettent √† jour
        console.log(
          'Navigation non disponible, r√©initialisation des √©tats uniquement',
        );
        // Vous pouvez ajouter ici une alerte ou un autre feedback utilisateur
        Alert.alert(
          'D√©connexion r√©ussie',
          "Vous avez √©t√© d√©connect√© avec succ√®s. Veuillez red√©marrer l'application.",
        );
      }
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
      Alert.alert(
        'Erreur de d√©connexion',
        'Une erreur est survenue lors de la d√©connexion. Veuillez r√©essayer.',
      );
    }
  };

  // Fonction pour g√©rer le suivi/d√©sabonnement d'un jeu
  const handleFollowGame = async (appId, isFollowed) => {
    try {
      if (!steamId) {
        console.error('SteamID non trouv√©');
        return;
      }

      if (!appId) {
        console.error('AppID non trouv√©');
        return;
      }

      // Convertir l'appId en cha√Æne
      const appIdString = appId.toString();

      console.log('=== D√©but handleFollowGame ===');
      console.log('AppID re√ßu:', appIdString);
      console.log('√âtat isFollowed:', isFollowed);
      console.log('Nombre total de jeux:', games.length);

      // Trouver le jeu dans la liste
      const game = games.find(g => {
        const gameId = getGameAppId(g);
        return gameId === appIdString;
      });

      if (!game) {
        console.error('Jeu non trouv√© dans la liste:', appIdString);
        console.log('=== Fin handleFollowGame (erreur) ===');
        return;
      }

      console.log('Jeu trouv√©:', game.name);

      // Mettre √† jour l'√©tat localement d'abord pour une UI r√©active
      const updatedGames = games.map(g => {
        const gameId = getGameAppId(g);
        if (gameId === appIdString) {
          return {...g, isFollowed: !isFollowed};
        }
        return g;
      });

      // Mettre √† jour l'√©tat des jeux
      setGames(updatedGames);

      try {
        // Appeler l'API pour mettre √† jour le suivi
        if (!isFollowed) {
          // Suivre le jeu
          await userService.followGame(
            steamId,
            appIdString,
            game.name,
            getGameIconUrl(appIdString, game.img_icon_url),
          );
          console.log('Jeu suivi avec succ√®s:', game.name);
        } else {
          // Ne plus suivre le jeu
          await userService.unfollowGame(steamId, appIdString);
          console.log('Jeu retir√© des suivis:', game.name);
        }

        // Recharger les donn√©es de l'utilisateur
        const userResponse = await userService.getUser(steamId);
        if (userResponse.data) {
          setUser(userResponse.data);
        }

        // Forcer le rafra√Æchissement de la liste filtr√©e
        filterAndSortGames();

        console.log('=== Fin handleFollowGame (succ√®s) ===');
      } catch (apiError) {
        console.error('Erreur API lors de la modification du suivi:', apiError);

        // Restaurer l'√©tat pr√©c√©dent
        setGames(games);

        Alert.alert(
          'Erreur',
          'Impossible de modifier le suivi du jeu. Veuillez r√©essayer.',
        );
      }
    } catch (error) {
      console.error('Erreur lors de la modification du suivi:', error);
      Alert.alert(
        'Erreur',
        'Une erreur inattendue est survenue. Veuillez r√©essayer.',
      );
    }
  };

  // Fonction pour v√©rifier les nouveaux jeux
  const checkForNewGames = async () => {
    try {
      if (!steamId) return;

      console.log('V√©rification des nouveaux jeux pour', steamId);
      // Pour v√©rifier les nouveaux jeux, on r√©cup√®re toujours tous les jeux
      const gamesResponse = await steamService.getUserGames(steamId, false);
      const newGames = Array.isArray(gamesResponse.data)
        ? gamesResponse.data
        : gamesResponse.data.games || [];

      if (!Array.isArray(newGames)) {
        console.log('Format de r√©ponse inattendu:', gamesResponse.data);
        return;
      }

      console.log(`Jeux r√©cup√©r√©s: ${newGames.length} jeux au total`);

      if (newGames.length > games.length) {
        console.log(
          `${newGames.length - games.length} nouveaux jeux d√©tect√©s!`,
        );

        // Convertir en Set pour une comparaison plus rapide
        const currentAppIds = new Set(games.map(game => game.appid.toString()));

        // Trouver les nouveaux jeux
        const addedGames = newGames.filter(
          game => !currentAppIds.has(game.appid.toString()),
        );

        if (addedGames.length > 0) {
          Alert.alert(
            'Nouveaux jeux d√©tect√©s',
            `${addedGames.length} nouveau(x) jeu(x) ont √©t√© ajout√©s √† votre biblioth√®que.`,
            [{text: 'OK'}],
          );

          // Mettre √† jour les jeux
          setGames(newGames);
          syncRecentActiveGames(newGames, steamId);
        }
      }
    } catch (error) {
      console.error('Erreur lors de la v√©rification des nouveaux jeux:', error);
    }
  };

  // La fonction isRecentlyUpdated est maintenant import√©e des utilitaires

  // V√©rifier si un jeu est suivi
  const isGameFollowed = appId => {
    if (!user || !user.followedGames) return false;

    // Nouvelle structure : array simple d'IDs
    if (typeof user.followedGames[0] === 'string') {
      return user.followedGames.includes(appId);
    }

    // Ancienne structure : array d'objets (compatibilit√©)
    return user.followedGames.some(game => game.appId === appId);
  };

  // Valeur du contexte
  const contextValue = {
    // √âtats
    games,
    filteredGames,
    loading,
    refreshing,
    steamId,
    user,
    searchQuery,
    sortModalVisible,
    sortOption,
    filterModalVisible,
    followFilter,

    // Setters
    setSearchQuery,
    setSortModalVisible,
    setSortOption,
    setFilterModalVisible,
    setFollowFilter,

    // Fonctions
    loadData,
    handleRefresh,
    handleLogout,
    handleFollowGame,
    checkForNewGames,
    isRecentlyUpdated,
    filterAndSortGames,
    isGameFollowed,
  };

  return (
    <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>
  );
};
